<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[linux网口绑定（bond）]]></title>
    <url>%2FLinuxService%2Flinux%E7%BD%91%E5%8F%A3%E7%BB%91%E5%AE%9A%EF%BC%88bond%EF%BC%89%2F</url>
    <content type="text"><![CDATA[通过网口绑定(bond)技术,可以很容易实现网口冗余，负载均衡，从而达到高可用高可靠的目的。 linux网口绑定（bond）通过网口绑定(bond)技术,可以很容易实现网口冗余，负载均衡，从而达到高可用高可靠的目的。 bond的类型网卡绑定mode共有七种(0~6) bond0、bond1、bond2、bond3、bond4、bond5、bond6 常用的有三种 mode=0：平衡负载模式，有自动备援，但需要”Switch”支援及设定。 mode=1：自动备援模式，其中一条线若断线，其他线路将会自动备援。 mode=6：平衡负载模式，有自动备援，不必”Switch”支援及设定。 配置案例物理网口：eth0、eth1 虚拟网口：bond0 配置bond1234567891011vim /etc/sysconfig/network-scripts/ifcfg-bond0DEVICE=bond0BOOTPROTO=noneONBOOT=yesIPADDR=192.168.1.101NETMASK=255.255.255.0NETWORK=192.168.1.0BROADCAST=192.168.1.255 //BROADCAST广播地址USERCTL=noBONDING_OPTS="mode=1 miimon=100" //mode：bond的模式,miimon：监测相应的时间，这里是100ms 配置eth0、eth1 123456789vim /etc/sysconfig/network-scripts/ifcfg-eth0DEVICE=eth0ONBOOT=yesNM_CONTROLLED=noBOOTPROTO=noneMASTER=bond0SLAVE=yesUSERCTL=no 123456789vim /etc/sysconfig/network-scripts/ifcfg-eth1DEVICE=eth1ONBOOT=yesNM_CONTROLLED=noBOOTPROTO=noneMASTER=bond0SLAVE=yesUSERCTL=no 修改modprobe相关设定文件，并加载bonding模块123456789vim /etc/modprobe.d/bonding.confalias bond0 bonding#options bonding max_bonds=2 miimon=200 mode=1 //如果在网卡配置文件中添加过bond选项，可忽略#选项：#miimon：监视网络链接的频度，单位是毫秒，我们设置的是200毫秒。#max_bonds：配置的bond口个数#mode：bond模式，主要有以下几种，在一般的实际应用中，0和1用的比较多， 加载模块(重启系统后就不用手动再加载了)1modprobe bonding //加载模块 1lsmod | grep bonding //查看是否加载成功 重启网络服务1/etc/init.d/network restart 查看bond状态12345678910111213141516171819202122232425262728cat /proc/net/bonding/bond0Ethernet Channel Bonding Driver: v3.7.1 (April 27, 2011)Bonding Mode: fault-tolerance (active-backup) //**active-backup(主备)模式**Primary Slave: NoneCurrently Active Slave: eth1 //**active状态的网口是eth1**MII Status: upMII Polling Interval (ms): 100Up Delay (ms): 0Down Delay (ms): 0Slave Interface: eth0MII Status: upSpeed: 1000 MbpsDuplex: fullLink Failure Count: 1Permanent HW addr: 00:0c:29:8a:f3:88Slave queue ID: 0Slave Interface: eth1MII Status: upSpeed: 1000 MbpsDuplex: fullLink Failure Count: 0Permanent HW addr: 00:0c:29:8a:f3:92Slave queue ID: 0 任意关掉一个网口，看看网络是否仍然连通如果不通，有可能是因为网关，需增加默认网关1234vim /etc/rc.d/rc.localifenslave bond0 eth0 eth1route add default gw 192.168.1.1 处于active状态下时eth0、eth1、bond1的物理地址都会相同，这样是为了避免上位交换机发生混乱。12345ifconfig | grep HWaddrbond0 Link encap:Ethernet HWaddr 00:0C:29:8A:F3:88 eth0 Link encap:Ethernet HWaddr 00:0C:29:8A:F3:88 eth1 Link encap:Ethernet HWaddr 00:0C:29:8A:F3:88 七种bond模式说明第一种模式：mod=0 ，即：(balance-rr) Round-robin policy（平衡抡循环策略） 特点：传输数据包顺序是依次传输（即：第1个包走eth0，下一个包就走eth1….一直循环下去，直到最后一个传输完毕），此模式提供负载平衡和容错能力；但是我们知道如果一个连接或者会话的数据包从不同的接口发出的话，中途再经过不同的链路，在客户端很有可能会出现数据包无序到达的问题，而无序到达的数据包需要重新要求被发送，这样网络的吞吐量就会下降 第二种模式：mod=1，即： (active-backup) Active-backup policy（主-备份策略） 特点：只有一个设备处于活动状态，当一个宕掉另一个马上由备份转换为主设备。mac地址是外部可见得，从外面看来，bond的MAC地址是唯一的，以避免switch(交换机)发生混乱。此模式只提供了容错能力；由此可见此算法的优点是可以提供高网络连接的可用性，但是它的资源利用率较低，只有一个接口处于工作状态，在有 N 个网络接口的情况下，资源利用率为1/N 第三种模式：mod=2，即：(balance-xor) XOR policy（平衡策略） 特点：基于指定的传输HASH策略传输数据包。缺省的策略是：(源MAC地址 XOR 目标MAC地址) % slave数量。其他的传输策略可以通过xmit_hash_policy选项指定，此模式提供负载平衡和容错能力 第四种模式：mod=3，即：broadcast（广播策略） 特点：在每个slave接口上传输每个数据包，此模式提供了容错能力 第五种模式：mod=4，即：(802.3ad) IEEE 802.3ad Dynamic link aggregation（IEEE 802.3ad 动态链接聚合） 特点：创建一个聚合组，它们共享同样的速率和双工设定。根据802.3ad规范将多个slave工作在同一个激活的聚合体下。 外出流量的slave选举是基于传输hash策略，该策略可以通过xmit_hash_policy选项从缺省的XOR策略改变到其他策略。需要注意的 是，并不是所有的传输策略都是802.3ad适应的，尤其考虑到在802.3ad标准43.2.4章节提及的包乱序问题。不同的实现可能会有不同的适应 性。 必要条件： 条件1：ethtool支持获取每个slave的速率和双工设定 条件2：switch(交换机)支持IEEE 802.3ad Dynamic link aggregation 条件3：大多数switch(交换机)需要经过特定配置才能支持802.3ad模式 第六种模式：mod=5，即：(balance-tlb) Adaptive transmit load balancing（适配器传输负载均衡） 特点：不需要任何特别的switch(交换机)支持的通道bonding。在每个slave上根据当前的负载（根据速度计算）分配外出流量。如果正在接受数据的slave出故障了，另一个slave接管失败的slave的MAC地址。 该模式的必要条件：ethtool支持获取每个slave的速率 第七种模式：mod=6，即：(balance-alb) Adaptive load balancing（适配器适应性负载均衡） 特点：该模式包含了balance-tlb模式，同时加上针对IPV4流量的接收负载均衡(receive load balance, rlb)，而且不需要任何switch(交换机)的支持。接收负载均衡是通过ARP协商实现的。bonding驱动截获本机发送的ARP应答，并把源硬件地址改写为bond中某个slave的唯一硬件地址，从而使得不同的对端使用不同的硬件地址进行通信。 来自服务器端的接收流量也会被均衡。当本机发送ARP请求时，bonding驱动把对端的IP信息从ARP包中复制并保存下来。当ARP应答从对端到达 时，bonding驱动把它的硬件地址提取出来，并发起一个ARP应答给bond中的某个slave。使用ARP协商进行负载均衡的一个问题是：每次广播 ARP请求时都会使用bond的硬件地址，因此对端学习到这个硬件地址后，接收流量将会全部流向当前的slave。这个问题可以通过给所有的对端发送更新 （ARP应答）来解决，应答中包含他们独一无二的硬件地址，从而导致流量重新分布。当新的slave加入到bond中时，或者某个未激活的slave重新 激活时，接收流量也要重新分布。接收的负载被顺序地分布（round robin）在bond中最高速的slave上 当某个链路被重新接上，或者一个新的slave加入到bond中，接收流量在所有当前激活的slave中全部重新分配，通过使用指定的MAC地址给每个 client发起ARP应答。下面介绍的updelay参数必须被设置为某个大于等于switch(交换机)转发延时的值，从而保证发往对端的ARP应答 不会被switch(交换机)阻截。 必要条件： 条件1：ethtool支持获取每个slave的速率； 条件2：底层驱动支持设置某个设备的硬件地址，从而使得总是有个slave(curr_active_slave)使用bond的硬件地址，同时保证每个bond 中的slave都有一个唯一的硬件地址。如果curr_active_slave出故障，它的硬件地址将会被新选出来的 curr_active_slave接管 其实mod=6与mod=0的区别：mod=6，先把eth0流量占满，再占eth1，….ethX；而mod=0的话，会发现2个口的流量都很稳定，基本一样的带宽。而mod=6，会发现第一个口流量很高，第2个口只占了小部分流量]]></content>
      <categories>
        <category>LinuxService</category>
      </categories>
      <tags>
        <tag>Centos</tag>
        <tag>bond</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zabbix4.2中文乱码解决]]></title>
    <url>%2FLinuxService%2Fzabbix4-2%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[zabbix从4.2.1版本往后，更改了字体文件的目录，所以新安装或是从4.0版本升级，字体都会出现乱码的情况 zabbix4.2中文乱码问题解决 字体文件目录: 12zabbix 4.2：/usr/share/zabbix/assets/fonts/zabbix 4.0：/usr/share/zabbix/fonts/ php 脚本文件位置: 1/usr/share/zabbix/include/defines.inc.php 将Win10操作系统C:\Windows\Fonts目录下的任意字体，拷贝到/usr/share/zabbix/assets/fonts/目录下（如果是zabbix4.0请拷贝到/usr/share/zabbix/fonts/这个目录下），更改后缀为’.ttf’ 修改php脚本文件 123vim /usr/share/zabbix/include/defines.inc.php 69 define('ZBX_GRAPH_FONT_NAME', 'msyh'); // font file name110 define('ZBX_FONT_NAME', 'msyh'); 重启zabbix服务RHEL 6 1service zabbix-server restart RHEL 7 1systemctl restart zabbix-server 刷新web界面，如果GG， 可按Ctrl+F5强制刷新即可]]></content>
      <categories>
        <category>LinuxService</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS6部署Zabbix4.2监控]]></title>
    <url>%2FLinuxService%2FCentOS6%E9%83%A8%E7%BD%B2Zabbix4-2%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[如果你想要在RHEL6安装zabbix的4.2版本，可以参考这篇文档 CentOS6部署Zabbix4.2监控 由于PHP版本，不支持RHEL 6上的Zabbix前端。由于Zabbix 3.0的要求是PHP 5.4.0或更高版本，而RHEL 6最新版本是5.3.3。在大多数情况下，Zabbix服务器和前端安装在同一台机器上。升级2.2到3.0时，Zabbix服务器将执行数据库升级，前端将停止工作。无法回滚数据库更改，用户将被迫使用第三方软件包升级PHP。这就是为什么Zabbix服务器在RHEL 6上也被弃用的原因。 先下载Zabbix官方在线源 1rpm -ivh https://repo.zabbix.com/zabbix/4.2/rhel/6/x86_64/zabbix-release-4.2-1.el6.noarch.rpm 安装epel在线源 1yum -y install epel-release 安装mysql安装mysql5.6在线源 1rpm -ivh http://dev.mysql.com/get/mysql-community-release-el6-5.noarch.rpm 安装mysql5.6数据库服务端 1yum -y install mysql-server 查看是否安装完成，版本5.6 1rpm -qa | grep mysql 启动mysql数据库 1service mysqld start 设置mysql密码及安全性设置 1mysql_secure_installation 进入数据库，新建zabbix库，新建zabbix用户，密码zabbix@123，刷新权限 12345mysql -uroot -pCREATE DATABASE zabbix CHARACTER SET utf8 COLLATE utf8_bin;GRANT ALL PRIVILEGES ON zabbix.* TO zabbix@localhost IDENTIFIED BY &apos;zabbix@123&apos;; flush privileges;exit 安装php使用第三方软件包升级PHP，则需要首先启用zabbix-deprecated存储库： 1234vim /etc/yum.repos.d/zabbix.repo找到[zabbix-deprecated]修改enabled = 1保存文件，退出 安装php5.6第三方在线源 1rpm -ivh http://repo.webtatic.com/yum/el6/latest.rpm 安装php5.6 1yum -y install httpd php56w php56w-gd php56w-mysql php56w-bcmath php56w-mbstring php56w-xml php56w-ldap php56w-pdo php56w-fpm 修改php.ini配置文件 123456vim /etc/php.ini663 post_max_size = 16M375 max_execution_time = 300385 max_input_time = 300889 date.timezone = Asia/Shanghai705 always_populate_raw_post_data = -1 安装zabbix-server安装zabbix-server，zabbix-mysql，zabbix-web软件包 1yum -y install zabbix-server-mysql zabbix-web-mysql zabbix-agent 导入数据文件，密码是zabbix用户的数据库密码 1zcat /usr/share/doc/zabbix-server-mysql*/create.sql.gz | mysql -uzabbix -p zabbix 修改zabbix_server配置文件 12vim /etc/zabbix/zabbix_server.conf124 DBPassword = zabbix@123 修改httpd配置文件 12vim /etc/httpd/conf/httpd.conf292 DocumentRoot "/usr/share/zabbix" 重启服务 123service zabbix-server restartservice zabbix-agent restartservice httpd restart Web端访问进行配置 Chrome &gt; 192.168.1.111 &gt; 向导安装 &gt; 完成 安装zabbix-agent 被监控端需安装zabbix-agent 1rpm -ivh https://repo.zabbix.com/zabbix/4.2/rhel/7/x86_64/zabbix-release-4.2-1.el7.noarch.rpm 1yum-config-manager --enable rhel-7-server-optional-rpms 1yum install zabbix-agent 12vim /etc/zabbix/zabbix_agentd.confServer=192.168.1.111 1systemctl start zabbix-agent]]></content>
      <categories>
        <category>LinuxService</category>
      </categories>
      <tags>
        <tag>Centos6</tag>
        <tag>zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7安装SQLServer2017]]></title>
    <url>%2FLinuxService%2FCentOS7%E5%AE%89%E8%A3%85SQLServer2017%2F</url>
    <content type="text"><![CDATA[在CentoOS上安装sqlserver，需要先下载微软官方提供的在线yum源，再安装mssql-server软件包，再根据需要安装sqlserver的命令行工具或远程客户端进行连接 CentOS7安装SQLServer2017 在CentoOS上安装sqlserver，需要先下载微软官方提供的在线yum源，再安装mssql-server软件包，再根据需要安装sqlserver的命令行工具或远程客户端进行连接 官方文档：https://docs.microsoft.com/en-us/sql/linux/quickstart-install-connect-red-hat OS必须条件Memory：3.25 GBFile System：XFS or EXT4 (other file systems, such as BTRFS, are unsupported)Disk space ：6 GBProcessor speed：2 GHzProcessor cores：2 coresProcessor type：x64-compatible only 安装mssql-server下载阿里云在线yum源到本地 1wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 下载微软官方的sqlserver源到本地 1wget -O /etc/yum.repos.d/mssql-server.repo https://packages.microsoft.com/config/rhel/7/mssql-server-2017.repo 最好查看一下内容是否正确 安装mssql-server（SQL Server软件包） 1yum install -y mssql-server 运行mssql-conf配置文件，选择SQL版本并配置SA密码（密码必须符合策略要求 ） 1/opt/mssql/bin/mssql-conf setup 这里有个小问题，服务器内存小于2G是无法正常安装的，所以需要调整内存或者自行百度 完成后，查看服务运行状态 1systemctl status mssql-server 要允许远程连接，允许firewalld防火墙上的SQLServer端口。 默认的 SQL Server 端口为 TCP 1433。 12sudo firewall-cmd --zone=public --add-port=1433/tcp --permanentsudo firewall-cmd --reload 安装sqlserver命令行工具 这时候安装已经完成，但是若要创建数据库或者本地连接数据库，则需要使用一个能够在SQLServer上运行Transact-SQL语句的工具进行连接。 以下步骤安装 SQL Server 命令行工具：sqlcmd和bcp。 下载微软官方的软件包yum源 1wget -O /etc/yum.repos.d/msprod.repo https://packages.microsoft.com/config/rhel/7/prod.repo 如果以前装过mssql，则需要删除较旧的UnixODBC软件包 1yum remove unixODBC-utf16 unixODBC-utf16-devel 安装mssql工具包和UnixODBC开发人员软件包 1yum install -y mssql-tools unixODBC-devel 为了方便使用工具包中的命令，添加PATH环境变量 12echo "export PATH=$PATH:/opt/mssql-tools/bin" &gt;&gt; /etc/profilesource /etc/profile 使用sqlcmd命令连接本地的sqlserver，输入之前设置的SA密码 1sqlcmd -S localhost -U SA -p 如果出现以下报错 123Sqlcmd: Error: Microsoft ODBC Driver 17 for SQL Server : Login timeout expired.Sqlcmd: Error: Microsoft ODBC Driver 17 for SQL Server : TCP Provider: Timeout error [258]. .Sqlcmd: Error: Microsoft ODBC Driver 17 for SQL Server : Unable to complete login process due to delay in prelogin response. 将localhost换成127.0.0.1，再次连接 1sqlcmd -S 127.0.0.1 -U SA -p 在本地创建新的数据库并查看 使用Navicat客户端远程连接 除了 sqlcmd, bcp, SSMS (on Windows)，还可以使用以下工具： SQL Operations Studio mssql-cli Visual Studio Code 检查安装的SQL Server版本1sqlcmd -S localhost -U SA -Q 'select @@VERSION' 卸载 SQL Server 如果安装了错误的版本或者需要卸载 只移除软件包本身 1yum remove mssql-server 移除包并不会删除生成的数据库文件。 需要手动删除 1rm -rf /var/opt/mssql/]]></content>
      <categories>
        <category>LinuxService</category>
      </categories>
      <tags>
        <tag>Centos7</tag>
        <tag>SQLServer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7 + ZABBIX4.2 + Grafana6.1]]></title>
    <url>%2FLinuxService%2FCentOS7%20%2B%20ZABBIX4.2%20%2B%20Grafana6.1%2F</url>
    <content type="text"><![CDATA[ZABBIX4.2+Grafana6.1的部署。Grafana是一个开源的度量分析与可视化套件，界面炫酷，数据体现较为直观。 ZABBIX 4.2 + Grafana 6.1部署环境准备 SNAME OS IP ROLE zabbix_server CentOS7.5_1804_64bit 192.168.31.194 server zabbix_client CentOS7.5_1804_64bit 192.168.31.214 client 升级系统组件版本(可选)1yum -y update SELinux配置启用Zabbix前端和服务器之间的通信： 1setsebool -P httpd_can_connect_zabbix on 如可以通过网络访问数据库，则还需要允许Zabbix前端连接到数据库： 1setsebool -P httpd_can_network_connect_db on 或直接关闭SELinux 1sed -i "s/SELINUX=enforcing/SELINUX=disabled/g" /etc/selinux/config 防火墙配置临时关闭firewall 1systemctl stop firewalld.service 禁止firewall开机启动 1systemctl disable firewalld.service 安装Zabbix-server 添加Zabbix存储库安装存储库配置包。该软件包包含yum（软件包管理器）的配置文件。 1rpm -ivh https://repo.zabbix.com/zabbix/4.2/rhel/7/x86_64/zabbix-release-4.2-1.el7.noarch.rpm 前端安装先决条件Zabbix前端需要额外的基本安装包。您需要在将运行Zabbix前端的系统中启用可选rpms的存储库： 1yum-config-manager --enable rhel-7-server-optional-rpms （如果提示没有yum-config-manager命令则使用yum -y install yum-utils后再次尝试） 服务器/代理/前端安装要在 MySQL支持下安装Zabbix服务器： 1yum -y install zabbix-server-mysql 要使用MySQL支持安装Zabbix-proxy： 1yum -y install zabbix-proxy-mysql 要在 MySQL支持下安装Zabbix前端： 1yum -y install zabbix-web-mysql MySQL安装CentOS自带的YUM仓库是不会自动更新每个软件的最新版本，所以无法通过YUM方式安装MySQL的高级版本。安装mysql5的解锁姿势是要先安装带有可用的mysql5系列社区版资源的rpm包 下载RPM包1wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm 1yum -y install mysql-community-release-el7-5.noarch.rpm 使用YUM的方式安装MySQL1yum -y install mysql-community-server 启动MySQL并设置开机启动12systemctl enable mysqldsystemctl start mysqld 创建数据库对于Zabbix_server和Zabbix_proxy守护程序，需要一个数据库。运行Zabbix_agent不需要它。 Zabbix_server和Zabbix_proxy需要单独的数据库; 他们不能使用相同的数据库。因此，如果它们安装在同一主上,则必须使用不同的名称创建其数据库！ 创建数据库123mysql -u rootmysql&gt; create database zabbix character set utf8 collate utf8_bin;mysql&gt; grant all privileges on zabbix.* to zabbix@localhost identified by &quot;Zabbix@123&quot;; 导入数据现在使用MySQL 导入服务器的初始模式和数据： 1zcat /usr/share/doc/zabbix-server-mysql*/create.sql.gz | mysql -uzabbix -p zabbix 系统将提示您输入新创建的数据库密码,当前环境的密码是上面设置的’Zabbix@123‘。 如果使用proxy，则使用这条命令导入数据库： 1zcat /usr/share/doc/zabbix-proxy-mysql*/schema.sql.gz | mysql -uzabbix -p zabbix_proxy 为Zabbix服务器/代理配置数据库编辑zabbix_server.conf（和zabbix_proxy.conf）以使用其各自的数据库。例如： 123456#vi /etc/zabbix/zabbix_server.conf DBHost = localhost DBName = zabbixzabbix DBUser = zabbixzabbix DBPassword = Zabbix@123在DBPassword中使用Zabbix数据库密码进行MySQL; 启动Zabbix服务器进程1systemctl start zabbix-server httpd 1systemctl enable zabbix-server httpd Zabbix前端配置对于RHEL 7及更高版本，Zabbix前端的Apache配置文件位于/etc/httpd/conf.d/zabbix.conf中。某些PHP设置已经配置。但是有必要取消注释“date.timezone”设置并为您设置正确的时区。 12345678php_value max_execution_time 300php_value memory_limit 128Mphp_value post_max_size 16Mphp_value upload_max_filesize 2Mphp_value max_input_time 300php_value max_input_vars 10000php_value always_populate_raw_post_data -1#php_value date.timezone Asia/Shanghai Web端访问进行配置http://192.168.31.194/zabbix/ 解决中文显示乱码的问题 将Win10操作系统C:\Windows\Fonts目录下的任意字体，拷贝到/usr/share/zabbix/fonts目录下，更改后缀为’’.ttf’ 123vim /usr/share/zabbix/include/defines.inc.php 69 define('ZBX_GRAPH_FONT_NAME', 'msyh'); // font file name114 define('ZBX_FONT_NAME', 'msyh'); 安装Zabbix-agent 被监控端需安装Zabbix-agent 1rpm -ivh https://repo.zabbix.com/zabbix/4.2/rhel/7/x86_64/zabbix-release-4.2-1.el7.noarch.rpm 1yum-config-manager --enable rhel-7-server-optional-rpms 1yum install zabbix-agent 12vim /etc/zabbix/zabbix_agentd.confServer=192.168.31.194 1systemctl start zabbix-agent Grafana 6.1部署 一款高颜值监控绘图工具Grafana，在使用Zabbix监控环境中，通常我们会结合Grafana进行图形展示。Grafana默认没有zabbix作为数据源，需要手动给zabbix安装一个插件，然后再添加进Grafana即可，非常简单。下面就介绍下Grafana的使用： Grafana的官网：http://docs.grafana.org/installation/rpm/ 安装RPM包1wget https://dl.grafana.com/oss/release/grafana-6.1.4-1.x86_64.rpm 1yum -y install fontconfig freetype* urw-fonts 1yum -y localinstall grafana-6.1.4-1.x86_64.rpm 启动Grafana并设置开机自启1systemctl enable grafana-server 1systemctl start grafana-server 安装grafana-zabbix插件1grafana-cli plugins install alexanderzobnin-zabbix-app 然后重启Grafana服务1systemctl restart grafana-server Web端访问3000端口http://192.168.31.194:3000 Grafana默认用户名：admin，密码：admin。需重置 Zabbix的API地址为 http://192.168.31.194/zabbix/api_jsonrpc.php]]></content>
      <categories>
        <category>LinuxService</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
        <tag>Centos7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LAMP平台部署及应用（CentOS_7）]]></title>
    <url>%2FLinuxService%2FLAMP%E5%B9%B3%E5%8F%B0%E9%83%A8%E7%BD%B2%E5%8F%8A%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[LAMP架构是目前成熟的企业网站应用模式之一，指的是协同工作的一整套系统和相关软件，能够提供动态Web站点服务及其应用开发环境 LAMP平台部署及应用（CentOS_7）LAMP平台概述 LAMP架构是目前成熟的企业网站应用模式之一，指的是协同工作的一整套系统和相关软件，能够提供动态Web站点服务及其应用开发环境。LAMP是一个缩写词，具体包括Linux操作系统、Apache网站服务器、MySQL数据库服务器、PHP（或Perl、Python）网页编程语言 构建LAMP时，各组件的安装顺序依次为Linux、Apache、MySQL、PHP，其中Apache和MySQL的安装并没有严格的顺序，而PHP环境的安装一般放到最后，负责沟通Web服务器和数据库系统以协同工作 LAMP的构成组件 Linux操作系统：作为LAMP架构的基础，提供用于支撑Web站点的d操作系统，能够与其他三个组件提供更好的稳定性、兼容性（AMP组件也支持Windows、UNIX等操作系统） Apache网站服务器：作为LAMP架构的前端，是一款功能强大、稳定性好的Web服务器程序，该服务器直接面向用户提供网站访问，发送网页、图片等文件内容 MySQL数据库服务器：作为LAMP架构的后端，是一款流行的开源关系数据库系统。在企业网站、业务系统等应用中，各种账户信息、产品信息、客户资料、业务数据等可以存储到MySQL数据库，其它程序可以通过MySQL语句来查询、更改这些信息 PHP、Perl、Python网页编程语言：作为三种开发动态网页的编程语言，负责解释动态网页文件，并提供Web应用程序的开发和运行环境。其中PHP是一种被广泛应用的开放源代码的多用途脚本语言，它可以嵌入到HTML中，尤其适合于Web应用开发 LAMP的应用优势 成本低廉：构成组件都是开放源代码的软件，可以自由获得和免费使用，在技术上和许可证方面没有太严格的限制，大大降低企业成本 可定制：拥有大量的额外组件和可扩展功能的模块，能够满足大部分企业应用的定制需求，甚至可以自行开发、添加新的功能 方便易用：PHP、Perl等属于解释性语言，开发的各种Web程序不需要编译，方便进行移植使用。整套的网站项目程序，通常只要复制到网站目录下，就可以直接访问 易于开发：基于LAMP平台的动态网站中，页面代码简洁，与HTML标记语言的结合度非常好，即使是非专业的程序员也能够轻松读懂乃至修改网页代码 安全和稳定：得益于开源的优势，大量的程序员在关注并持续改进LAMP平台的各个组件，发现的问题能够很快得到解决。LAMP架构已经经历了数十年的长期验证，在安全性和稳定性方面表现得非常优秀 使用YUM安装 系统环境： CentOS 7.5.1804_64bit LAMP各组件版本： 跟随YUM仓库内软件包的版本 安装LAMP软件包1yum install httpd httpd-devel mysql mysql-server mysql-devel php php-mysql php-gd php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-snmp php-soap curl curl-devel php-bcmath 设置mysql密码1mysql -u root 123mysql&gt;USE mysql; mysql&gt;UPDATE user SET Password=PASSWORD(&apos;newpassword&apos;) WHERE user=&apos;root&apos;; mysql&gt;FLUSH PRIVILEGES; 允许远程登录mysql数据库12mysql -u root -p Enter Password: &lt;your new password&gt; 1mysql&gt;GRANT ALL PRIVILEGES ON . TO &apos;用户名&apos;@&apos;%&apos; IDENTIFIED BY &apos;密码&apos; WITH GRANT OPTION; 防火墙设置开启80、443端口123firewall-cmd --permanent --zone=public --add-service=httpfirewall-cmd --permanent --zone=public --add-service=httpsfirewall-cmd –reload 服务开机自启动12systemctl enable httpdsystemctl enable mysqld 使用源码编译安装 系统环境： CentOS 7.5.1804_64bit LAMP各组件版本： httpd-2.4.38、mysql-5.6.43、php-7.3.3 安装Apache（2.4）准备工作1234567891011121314151617181920212223242526rpm -e httpd --nodeps//卸载使用RPM方式安装的httpdyum -y install -y apr apr-util pcre apr-devel apr-util-devel pcre-devel gcc//安装依赖软件包wget http://www.openssl.org/source/openssl-1.1.0-latest.tar.gz//安装Openssl支持https协议访问，下载源码包tar -zxvf openssl-1.1.0-latest.tar.gz -C /usr/src///解包cd /usr/src/openssl-1.1.0j///进入解压目录./config --prefix=/usr/local/ssl –shared//配置编译选项make &amp;&amp; make install//编译安装echo /usr/local/ssl/lib/ &gt;&gt;/etc/ld.so.conf//将动态库路径加入系统路径中ldconfig//加载动态库以便系统共享 下载Apache源码包：http://httpd.apache.org/download.cgi 源码编译及安装。1234567891011tar -zxvf httpd-2.4.38.tar.gz -C /usr/src///解包cd /usr/src/httpd-2.4.38///进入解压目录./configure --prefix=/usr/local/httpd --enable-so --enable-rewrite --enable-ssl --with-ssl=/usr/local/ssl --with-mpm=prefork --enable-charset-lite --enable-cgi//配置编译选项make &amp;&amp; make install//编译并安装 优化执行路径12345echo "PATH=$PATH:/usr/local/httpd/bin/" &gt;&gt;/etc/profile//将Apache命令添加到PATH搜索路径中，写入/etc/profile永久保存source /etc/profile//立即读取/etc/profile生效配置 添加httpd为系统服务1234567891011121314151617cp /usr/local/httpd/bin/apachectl /etc/init.d/httpd//拷贝默认启动脚本文件到服务控制目录vim /etc/init.d/httpd#!/bin/sh# chkconfig:235 88 88 /服务识别参数，指定3、5级别顺序启动标识号# description:httpd server /描述（需配套使用）//文件开头添加chkconfig识别配置，不添加chkconfig添加服务时报错chkconfig --add httpd//将httpd添加为系统服务systemctl enable httpd//开机自启动chkconfig --list httpd//查看httpd服务的自启动状态 配置并启动httpd服务123456789101112vim /usr/local/httpd/conf/httpd.conf197 ServerName www.hiahia.com:80//编辑httpd主配置文件，寻找该行（197行） ，设置网站名称apachectl -t//检测httpd.conf文件是否有语法错误；“Syntax OK”则无误systemctl start httpd//启动httpd服务systemctl status httpd//查看httpd服务运行状态 访问测试首先需要解决防火墙问题，CentOS7默认自带的防火墙为firewalld，解决方法如下，二选一。 12345678firewall-cmd --permanent --zone=public --add-service=httpfirewall-cmd --permanent --zone=public --add-service=httpsfirewall-cmd –reload//允许firewall防火墙通过80、443端口systemctl stop firewalldsystemctl disable firewalld//关闭firewall防火墙，并且开机禁用 //访问服务器地址测试 安装MySQL（5.6）准备工作12345rpm -e mysql-server mysql//卸载使用RPM方式安装MySQL软1件包yum -y install ncurses-devel cmake//安装依赖软件包 下载MySQL5.6源码包https://dev.mysql.com/downloads/mysql/ 源码编译及安装123456789101112131415161718192021222324252627tar -zxvf mysql-5.6.43.tar.gz -C /usr/src///解包useradd -M -r -s /sbin/nologin mysql//新建mysql系统用户mkdir -p /data/mysql/data//嵌套创建数据目录chown -R mysql.mysql /data/mysql/data///更改数据目录属主和属组cd /usr/src/mysql-5.6.43///进入解压目录cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DMYSQL_DATADIR=/data/mysql/data -DSYSCONFDIR=/etc -DWITH_EXTRA_CHARSETS=all -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci编译选项：-DCMAKE_INSTALL_PREFIX：指定MySQL安装位置-DDEFAULT_CHARSET：指定默认字符集编码-DDEFAULT_COLLATION：指定默认使用字符集校对规则-DWITH-EXTRA-CHARSETS：指定额外支持的其他字符集编码-DSYSCONFDIR：配置文件存储位置//配置编译选项make &amp;&amp; make install//编译并安装 安装后的其它调整12345678910111213141516171819202122chown -R mysql.mysql /usr/local/mysql///更改安装目录属主和属组rm -rf /etc/my.cnf//删除默认存在my.cnf文件mv /usr/local/mysql/my.cnf /etc/my.cnf//移动默认的配置文件到/etc/下/usr/local/mysql/scripts/mysql_install_db --user=mysql --basedir=/usr/local/mysql/ --datadir=/data/mysql/data选项：--user：指定运行用户--basedir：指定MySQL数据库位置--datadir：指定MySQL数据存储位置//执行初始化数据库脚本echo "PATH=$PATH:/usr/local/mysql/bin"&gt;&gt;/etc/profile//添加MySQL到搜索路径，方便执行命令source /etc/profile//立即让profile文件内容生效 添加系统服务1234567891011cp /usr/src/mysql-5.6.43/support-files/mysql.server /etc/init.d/mysqld//拷贝服务脚本文件到/etc/init.d位置chkconfig --add mysqld//添加为系统服务systemctl enable mysqld//设置开机自启chkconfig --list mysqld//查看开机启动状态 访问测试12mysql – uroot -p//登入mysql，默认没有密码，直接回车即可 安装PHP（7.3）准备工作12345rpm -e php php-cli php-ldap php-common php-mysql --nodeps//卸载使用RPM等方式安装的PHP相关软件包yum -y install zlib-devel libxml2-devel libtool-ltdl-devel//安装依赖包 编译安装PHP123456789101112131415161718192021222324252627tar -zxvf php-7.3.3.tar.gz -C /usr/src///解包cd /usr/src/php-7.3.3///定制PHP的配置选项时，最关键的是要指定httpd、mysqld的安装路径，以便添加相应支持设置，使LAMP各组件协同工作。除此之外，还可以指定安装路径、启动多字节支持、加密扩展支持等，请按需添加。./configure --prefix=/usr/local/php --with-apxs2=/usr/local/httpd/bin/apxs --with-pdo-mysql=/usr/local/mysql/ --with-openssl --with-config-file-path=/usr/local/php --with-mysqli=/usr/local/mysql/bin/mysql_config --with-mhash --enable-mbstring编译选项（./configure --help 查看编译参数）：--prefix：指定PHP安装目录--with-apxs2：设置Apache HTTP Server提供的apxs模块支持程序的文件位置--with-mysqli：安装mysqli扩展--with-pdo-mysql：安装pdo扩展--with-openssl：添加openssl支持--with-config-file-path：设置PHP的配置文件php.ini将要存放的位置--enable-mbstring：启动多字节字符串功能，以便支持中文等代码make &amp;&amp; make install//编译并安装php -v//安装完成查看版本echo "PATH=$PATH:/usr/local/php/bin" &gt;&gt; /etc/profile//命令目录加入PATH搜索路径source /etc/profile//立即读取文件，生效配置 配置PHP-FPM12345678910111213141516171819cp php-7.3.3/php.ini-development /usr/local/php/php.ini//拷贝php.ini模板配置文件，下面会详细讲解cp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.confcp /usr/local/php/etc/php-fpm.d/www.conf.default /usr/local/php/etc/php-fpm.d/www.conf//拷贝php-fpm模板配置文件cp sapi/fpm/init.d.php-fpm /etc/init.d/php-fpm//拷贝启动脚本到服务管理目录chmod +x /etc/init.d/php-fpm//给予启动脚本执行权限/etc/init.d/php-fpm start//启动php-fpmps -ef | grep php//查看php-fpm进程 安装Mcrypt扩展实际企业应用中，一部分基于PHP开发的Web应用系统会需要额外的扩展工具，如数据加密工具libmcrypt、mhash、mcrypt等 PHP7 要想使用 Mcrypt, 需要安装相应依赖包以及扩展模块，mcrypt 扩展从 php 7.1.0 开始废弃；自 php 7.2.0 起，会移到 pecl 在 php 官网下载 mcrypt 包 http://pecl.php.net/package/mcrypt 123456789101112131415161718192021222324252627yum install libmcrypt libmcrypt-devel mcrypt mhash// yum 安装依赖包wget http://pecl.php.net/get/mcrypt-1.0.2.tgz//wget下载软件包到本地tar -xf mcrypt-1.0.2.tgz -C /usr/src///解包cd /usr/src/mcrypt-1.0.2///进入解压目录/usr/local/php/bin/phpize./configure --with-php-config=/usr/local/php/bin/php-config//配置编译选项mcryptmake &amp;&amp; make install &amp;&amp; make test//编译并安装vim /usr/local/php/php.iniextension=mcrypt.so//在php.ini加上mcrypt扩展选项/etc/init.d/php-fpm restart//重启 php-fpm 设置LAMP组件环境设置LAMP组件环境，主要包括对PHP的配置文件php.ini、Apache的配置文件httpd.conf的调整。前者用来确定PHP的运行参数，后者用来加载libphp7.so，以便支持PHP网页 php.ini配置调整安装好PHP软件包以后，服务器并不会自动创建php.ini配置文件，但在源码目录下提供两个样例配置文件，分别对应于开发环境、生产环境 /usr/src/php-7.3.3/php.ini-development //开发版样例文件，用于学习、测试 /usr/src/php-7.3.3/php.ini-production //生产版样例文件，用于实际运营 选择其中一个样例文件，并复制到PHP配置文件目录/usr/local/php下，并改名为php.ini。在php.ini配置文件中，以分号开头的内容表示注释信息 1cp /usr/src/php-7.3.3/php.ini-development /usr/local/php/php.ini 通过修改php.ini文件中的配置内容，可以控制PHP网页的执行特性，如是否允许用户上传文件、设置上传文件的大小限制、设置默认使用的字符集、加载额外的扩展模块等。如果没有特殊要求，可以沿用默认配置，不做任何修改 1234567vim /usr/local/php/php.inidefault_charset = "utf-8" //设置默认字符集为utf-8file_uploads = On //允许通过PHP网页上传文件upload_max_filesize = 2M //允许上传的文件大小限制max_file_uploads = 20 //每个HTTP最多允许请求上传的文件数post_max_size = 8M //每次提交表单post提交的数据量限制192 short_open_tag = On //允许识别PHP短语法标记，即&lt;?...?&gt; httpd.conf配置调整要使httpd服务器支持PHP页面解析功能，需通过LoadModule配置项加载PHP程序的模块文件，并通过AddType配置项添加对“.php”类型网页文件的支持。除此还应修改Directory配置行，添加index.php配置项，以识别常见的PHP首页文件 1234vim /usr/local/httpd/conf/httpd.conf156 LoadModule php7_module modules/libphp7.so394 AddType application/x-httpd-php .php256 DirectoryIndex index.html index.php 上述配置中，LoadModule行在安装PHP过程自动添加，其中的“php7_module”表示模块名称；“modules/libphp7.so”表示模块文件位置。而AddType行需要手动添加，DirectoryIndex行原有基础上对其进行修改即可 测试LAMP协同工作测试PHP网页能否正确显示编写“.php”格式的测试网页文件，使用PHP内建的“phpinfo()”函数显示服务器的PHP环境信息，PHP代码应包括在“&lt;?php …?&gt;”标记字之间。将测试网页文件放置到网站根目录下 1234vim /usr/local/httpd/htdocs/test1.php&lt;?phpphpinfo();?&gt; 12systemctl restart httpd//重启httpd服务 //可以看到刚刚安装的mcrypt扩展被php成功加载 测试PHP网页能否访问MySQL数据库编写测试网页文件test2.php和test3.php，添加简单的数据库操作命令，用于验证与MySQL服务器的连接、查询等操作。其中“PDO()”“mysqli()”函数用于连接MySQL数据库，需要指定目标主机地址，以及授权访问的用户名、密码（可为空）。 ​ 题外话：使用PDO或mysqli都可以连接mysql，但更推荐使用PDO连接数据库，因为PDO支持12种不同的数据库驱动程序，mysqli只支持mysql，而且PDO性能更高。 ​ 这里需要测试的是，是否两种方法都可用，如果其中一种方法不可用。请自行安装该方法的扩展包，然后再次测试。 123456789101112vim /usr/local/httpd/htdocs/test2.php&lt;?php $mysqli=new PDO('mysql:host=localhost;port=3306','root',''); if(!$mysqli) &#123; echo"database error"; &#125; else&#123; echo"php env successful"; &#125; $mysqli = null;?&gt;//php代码大意：使用php语言新建一个数据库连接，如果连接失败则返回字符“database error”否则返回字符“php env successful”代表数据库连接成功。php环境搭建完成 1234567891011vim /usr/local/httpd/htdocs/test3.php&lt;?php $mysqli = new mysqli('localhost','root',''); if(!$mysqli) &#123; echo"database error"; &#125; else&#123; echo"php env successful"; &#125; $mysqli-&gt;close();?&gt; LAMP架构应用案例 部署phpMyAdmin系统phpMyAdmin是一个使用PHP语言编写的lamp管理套件，用来图形化管理MySQL数据库的Web应用系统。 下载软件包下载最新版本即可，官网：https://www.phpmyadmin.net/ 以多国语言版源码包phpMyAdmin-4.8.5-all-languages.tar.gz为例安装 解包并复制到网站目录1234tar -zxvf phpMyAdmin-4.8.5-all-languages.tar.gzmv phpMyAdmin-4.8.5-all-languages/ /usr/local/httpd/htdocs/phpMyAdmin//移动到网站目录下重命名为phpMyAdmin 建立配置文件config.inc.php1cp /usr/local/httpd/htdocs/phpMyAdmin/config.sample.inc.php /usr/local/httpd/htdocs/phpMyAdmin/config.inc.php 访问phpMyAdmin的web管理界面域名后缀加/phpMyAdmin访问 12mysqladmin -u root password "pwd@123"//phpMyAdmin登陆需要数据库密码，所以设置root用户密码，测试使用。一般不建议使用这种方式设置密码，因为是明文的，可以通过历史命令查看到。 //部署完成，可以通过可视化web界面管理数据库]]></content>
      <categories>
        <category>LinuxService</category>
      </categories>
      <tags>
        <tag>LAMP</tag>
        <tag>CentOS7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVM虚拟化]]></title>
    <url>%2FKVM%2FKVM%E8%99%9A%E6%8B%9F%E5%8C%96%2F</url>
    <content type="text"><![CDATA[KVM是开源软件，全称是kernel-based virtual machine（基于内核的虚拟机）。使用半虚拟化技术创建虚拟机的模块，可以将Linux内核转化为一个hypervisor。在KVM环境中运行的每个虚拟化操作系统都将表现为单个独立的系统进程。因此它可以很方便地与Linux系统中的安全模块进行整合（SElinux），可以灵活地实现资源的管理及分配 KVM架构与管理1.1 KVM架构1.虚拟化概述名词：物理机或宿主机（Host，即真机）、虚拟机里面系统（Guest OS）、虚拟机管理程序（VDSM或hypervisor） 虚拟化（系统虚拟化）：一个物理机上开很多虚拟机，实现互不干扰；虚拟硬件使用物理机硬件资源，每个虚拟机拥有独立的硬件资源 虚拟机不能直接与物理机资源访问，必须通过VMM（虚拟机管理程序，即VDSM或称Hypervisor)才能访问物理机资源 虚拟化类型 全虚拟化（本地虚拟化、硬件辅助全虚拟化）：虚拟机中运行的软件与系统不需经过任何修改，就好比运行在真实硬件一样；但依然使用虚拟硬件设备，并且需要硬件支持，物理机需支持虚拟化功能（grep -E ‘vmx|svm’ /proc/cpuinfo，查询intel与AMD是否支持） 半虚拟化：另一种类似于全虚拟化的热门技术，它使用Hypervisor(虚拟机管理程序)分享存取底层的硬件, 但是它的客户操作系统集成了虚拟化方面的代码，该方法无需重新编译或引起陷阱，因为操作系统自身能够与虚拟进程进行很好的协作；但半虚拟化需要客户操作系统做一些修改（配合VDSM），这是一个不足之处，但是半虚拟化提供了与原始系统相近的性能，与全虚拟化一样，半虚拟化可以同时能支持多个不同的操作系统 2.虚拟机概述虚拟机：运行在计算机上的一款软件程序，模拟计算机硬件的功能，为其他软件程序提供一个独立的计算机环境；使用资源为真机资源 虚拟机的运行架构 传统运行模式：一台计算机同时只能运行一个操作系统，在系统之上运行运用软件 寄居架构：将虚拟机软件安装在操作系统之上，作为一个应用程序，在虚拟机软件创建出来的虚拟机上还可以安装操作系统软件 原生架构（裸金属架构）：虚拟机软件不需要依赖其他操作系统，直接安装在计算机硬件上，虚拟机软件本身就是一个操作系统 3.KVM简介 KVM是开源软件，全称是kernel-based virtual machine（基于内核的虚拟机）。使用半虚拟化技术创建虚拟机的模块，可以将Linux内核转化为一个hypervisor。目前Red Hat只支持在64位的RHEL 5.4及以上的系统运行KVM（其余发行版也可使用），同时硬件需要支持VT技术；KVM的前身是QEMU，2008年被Red Hat公司收购并获得一项hypervisor技术，不过Red Hat的KVM被认为是将成为未来Linux hypervisor的主流，准确来说，KVM仅仅是Linux内核的一个模块，管理和创建完整的KVM虚拟机，需要更多的辅助工具 KVM在2007年2月被整合到Linux 2.6.20核心中，以可加载核心模块的方式被移植到FreeBSD及illumos上，它依托CPU和虚拟化指令集（如Inter-VT、AMD-V）实现高性能的虚拟化支持；由于与Linux内核高度整合，因此在性能、安全性、兼容性、稳定性上都有很好的表现 KVM是x86架构且硬件支持虚拟化技术（如 intel VT 或 AMD-V）的Linux全虚拟化解决方案。它包含一个为处理器提供底层虚拟化 可加载的核心模块kvm.ko（kvm-intel.ko或kvm-AMD.ko）。KVM还需要一个经过修改的QEMU软件（qemu-kvm），作为虚拟机上层控制和界面。KVM能在不改变linux或windows镜像的情况下同时运行多个虚拟机，（它的意思是多个虚拟机使用同一镜像）并为每一个虚拟机配置个性化硬件环境（网卡、磁盘、图形适配器……）。 ​ 图上简单描述了KVM虚拟化架构，在KVM环境中运行的每个虚拟化操作系统都将表现为单个独立的系统进程。因此它可以很方便地与Linux系统中的安全模块进行整合（SElinux），可以灵活地实现资源的管理及分配 1.2 KVM安装安装前要查看 CPU 是否支持虚拟化 12Intel CPU：cat /proc/cpuinfo |grep --color vmxAMD CPU：cat /proc/cpuinfo |grep --color smv //若以上操作有输出,就说明 CPU 支持虚拟化 实验环境注意勾选”CPU虚拟化” 1.安装方式新装系统最简单的安装方法就是在安装系统的时候，选择桌面安装，然后选择虚拟化选项 已装系统在已有系统基础上，只需安装KVM所需软件即可1234567891011121314151617181920rm -rf /etc/yum.repos.d/* //删除默认自带YUM源（自带源为官方在线，需联网）vim /etc/yum.repos.d/local.repo //自行新建本地YUM [local] //仓库名称定义 name=local //标识名 baseurl=file:///mnt //指定源文件所在位置（该处为光盘挂载点） enabled=1 //启用该仓库 gpgcheck=0 //不验证软件包密钥yum clean all &amp;&amp; yum repolist //清除YUM缓存并重新生成mount /dev/cdrom /mnt/ //挂载光盘到/mnt/目录yum -y groupinstall "Desktop" //安装GNOME桌面环境yum -y install qemu-kvm //KVM模块yum -y install qemu-kvm-tools //KVM调试工具，可不安装yum -y install python-virtinst //python组件，记录创建VM时的xml文件yum -y install qemu-img //qemu组件，创建磁盘、启动虚拟机等yum -y install bridge-utils //网络支持工具yum -y install libvirt //虚拟机管理工具yum -y install virt-manager //图形界面管理虚拟机yum -y install libguestfs-tools //virt-cat等命令的支持软件包reboot //重启系统lsmod | grep kvm //检查KVM模块是否安装 2.设置KVM网络宿主服务器安装完成KVM，首先要设定网络，在libvirt中运行KVM网络有两种方法：NAT和Bridge，默认是NAT 用户模式：即NAT方式，这种方式是默认网络，数据包由NAT方式通过主机的接口进行传送，可以访问外网，但是无法从外部访问虚拟机网络 桥接模式：即Bridge方式，这种模式允许虚拟机像一台独立的主机一样拥有网络，外部的机器可以直接访问到虚拟机内部，但需要网卡支持，一般有线网卡都支持 Bridge（桥接）模式配置1234567891011121314vim /etc/sysconfig/network-scripts/ifcfg-eth0 DEVICE=eth0 //网卡名称 TYPE=Ethernet //网卡类型为以太网 ONBOOT=yes //开机自启该网卡 NM_CONTROLLED=no //关闭NetworkManager BOOTPROTO=none //不指定网卡配置信息（由br0网卡提供） BRIDGE="br0" //桥接虚拟网卡名称vim /etc/sysconfig/network-scripts/ifcfg-br0 DEVICE=br0 //网卡名称 TYPE=Bridge //网卡类型为网桥 ONBOOT=yes //开机自启该网卡 NM_CONTROLLED=no //关闭NetworkManager BOOTPROTO=dhcp //网卡设置为动态获取方式/etc/init.d/network restart //重启网络服务 出现以上信息，说明网卡桥接成功了 1.3 KVM虚拟机安装1.创建存储池在安装虚拟机之前，为了方便管理虚拟机的磁盘及镜像文件，一般建议单独新建存储池（即磁盘文件和镜像存储位置指定） 1mkdir -pv /kvm/&#123;store,iso&#125; //新建磁盘及镜像存储目录 1virt-manager //运行虚拟机管理软件 双击localhost（QEMU），选择”存储选项卡”，然后单击”+”按钮新建存储池 根据提示输入存储池名称，如store 指定store存储池里面内容的存储目录（该处为之前新建的/kvm/store） 同样的操作再创建一个镜像存储池，命名为iso 目录为kvm/iso即可 2.上传镜像到镜像池存储池创建完成后，就可以将安装系统的ISO镜像文件上传到/kvm/iso目录，以方便后续安装系统使用 上传过程略…，这里以Centos 6.7 64bit镜像为例 cp /root/CentOS-6.7-x86_64-bin-DVD1.iso /kvm/iso/ 3.新建存储卷存储卷即安装系统时虚拟机所使用的磁盘文件，那么在vmware软件中是在新建虚拟机时可选择磁盘文件的位置和大小，而KVM可提前新建虚拟机所使用磁盘文件及大小（当然也可直接使用默认KVM创建的default存储池空间），相比更加灵活 单击刚创建好的”store”存储池，单击对话框右下角的”新建卷”按钮建立一个存储卷 设置新建存储卷取名并指定卷最大容量与分配容量（Format选择”qcow2”不然不能快照） 4.新建虚拟机 回到虚拟系统管理器后，选择”New”选项 指定新建虚拟机名称为”Centos_6.7”，并指定从本地或光盘中选择镜像安装系统 指定新建虚拟机采用的系统及对应版本，并”Browse”浏览本地选择镜像 选择之前创建的镜像存储池”iso”中上传的镜像用于安装系统 指定新建虚拟机采用的内存及CPU核心数 选择虚拟机产生文件存储位置，这里选择之前新建存储卷”Centos_6.7”使用它的空间 选择”Customize …”完成后打开虚拟机编辑页面调整虚拟机配置 调整虚拟机时间为”localtime”本地时间 “虚拟机”键盘布局和真机一样（一定选择，不然里面键盘输入有问题） 开始引导安装系统（其余硬件调整和VMware使用差不多，这里不再阐述） 安装过程略。 1.4 KVM基本功能管理1.KVM配置文件存放目录1ls /etc/libvirt/qemu 2.查看虚拟机状态1virsh list --all //查看所有KVM虚拟机状态 3.虚拟机关机、开机、开机自启等操作关机1virsh shutdown Centos_6.7 //关闭名为Centos_6.7的KVM虚拟机 注：KVM虚拟机默认是无法用virsh shutdown进行关机的，如果要想使用该命令关机，则必须在kvm虚拟机上安装acpid包，启动acpid服务，并且加入开机启动（并且shutdown命令只能在虚拟机启动后才能关闭） 开机1virsh start Centos_6.7 //开启名为Centos_6.7的KVM虚拟机 强制关机1virsh destroy Centos_6.7 //强制关闭名为Centos_6.7的虚拟机 挂起（暂停）1virsh suspend Centos_6.7 //挂起名为Centos_6.7的虚拟机 恢复虚拟机1virsh resume Centos_6.7 //恢复被暂停的名为Centos_6.7虚拟机 开机自启KVM虚拟机1virsh autostart Centos_6.7 //Centos_6.7虚拟机伴随宿主机自动启动 配置文件备份12virsh dumpxml Centos_6.7 &gt;/etc/libvirt/qemu/Centos_6.7.xml.bak//导出虚拟机配置文件做备份（配置文件中存储虚拟机配置情况等，如CPU、内存等） 删除KVM虚拟机1virsh undefine Centos_6.7 //删除名为Centos_6.7的KVM虚拟机 注：”undefine”选项只会删除该虚拟机配置文件，而使用的磁盘文件不会删除，如需要彻底删除注意删除磁盘文件；如果只是删除配置文件，当有备份的配置文件时，还可恢复该虚拟机 ​ 如上图，可以看出，只是配置文件删除，磁盘文件依然存在 添加KVM虚拟机12virsh define /etc/libvirt/qemu/Centos_6.7.xml.bak//通过之前备份的配置文件，重新将Centos_6.7虚拟机添加 修改KVM虚拟机配置信息1virsh edit Centos_6.7 //编辑虚拟机Centos_6.7的配置文件 1vim /etc/libvirt/qemu/Centos_6.7.xml //也可直接编辑配置文件，但不建议使用 1.5 KVM高级功能管理1.raw磁盘格式转换为qcow2磁盘格式 KVM虚拟机常用磁盘格式为raw与qcow2格式，默认使用raw格式，那么其中raw格式的磁盘性能最好、速度最快，但不支持AES加密、zlib磁盘压缩等新功能，而qcow2格式磁盘存储空间更小，并支持AES加密、zlib、快照等新功能，缺点是性能较差 如果想管理指定虚拟机磁盘（如分区情况、磁盘数量等），可以使用”libguestfs-tools”工具（一般默认安装），下面举例，说明如和转换磁盘格式 12qemu-img info /kvm/store/Centos_6.7.img//查看指定磁盘文件的信息（如磁盘格式、占用磁盘大小等） 1qemu-img convert -f raw -O qcow2 &lt;raw格式磁盘镜像路径&gt; &lt;qcow2格式磁盘镜像路径&gt; 选项： -c：对输出的镜像文件进行压缩，但只有qcow2和qcow格式支持 -f：指定源磁盘格式 -O：指定转换后磁盘格式 12qemu-img convert -f raw -O qcow2 /kvm/store/Centos_6.7.img /kvm/store/Centos_6.7.qcow2//将指定raw格式文件转换为qcow2磁盘格式文件（注意该虚拟机需关机） 1qemu-img info /kvm/store/Centos_6.7.qcow2 //查看转换后磁盘格式信息 注：转换后，需更改KVM虚拟机配置文件，因为虚拟机中还是用原磁盘格式文件，需要更改为新转换后的磁盘文件，才能使用新磁盘格式 123virsh edit Centos_6.7 //编辑指定名为Centos_6.7虚拟机配置文件 24 &lt;driver name='qemu' type='qcow2' cache='none'/&gt; 25 &lt;source file='/kvm/store/Centos_6.7.qcow2'/&gt; 1virsh start Centos_6.7 //启动该KVM虚拟机 2.管理KVM虚拟机文件1234virt-cat -a 磁盘文件路径 文件绝对路径//查看指定KVM虚拟机磁盘文件里指定路径内容virt-cat -a /kvm/store/Centos_6.7.qcow2 /etc/sysconfig/network//查看Centos_6.7.qcow2磁盘文件中/etc/sysconfig/network内容 1234virt-edit -a 磁盘文件路径 文件决定路径//编辑指定KVM虚拟机磁盘文件里指定路径内容virt-edit -a /kvm/store/Centos_6.7.qcow2 /etc/sysconfig/network//编辑Centos_6.7例的/etc/sysconfig/network文件 12virt-df -h 虚拟机名称//查看指定KVM虚拟机磁盘使用情况 3.虚拟机克隆克隆：即将虚拟机复制一份，快速创建一个同样的虚拟机，节省时间并提高创建效率123virt-clone -o 源虚拟机名称 -n 克隆的虚拟机名称 -f 克隆的虚拟机磁盘文件路径virt-clone -o Centos_6.7 -n Centos_6.7_clone -f /kvm/store/Centos_6.7_clone.qcow2//将Centos_6.7虚拟机克隆，生成Centos_6.7_clone并指定磁盘文件路径（注意克隆的虚拟机必须关机） 4.虚拟机快照快照：将虚拟机系统的某个状态保存，通过快照可快速恢复到虚拟机系统的某个状态 注：KVM快照只支持qcow2磁盘格式，如不是需转换 创建快照12virsh snapshot-create 虚拟机名称virsh snapshot-create Centos_6.7 //给名为Centos_6.7虚拟机创建快照 查看快照信息12virsh snapshot-list 虚拟机名称virsh snapshot-list Centos_6.7 //查看指定虚拟机所有创建的快照信息 1virsh snapshot-current Centos_6.7 //查看名为Centos_6.7虚拟机详细快照信息 恢复快照123virsh snapshot-revert 虚拟机名称 快照序号virsh snapshot-revert Centos_6.7 1520271801//将名为Centos_6.7的虚拟机恢复到"Name"为1520271801时的状态 删除快照123virsh snapshot-delete 虚拟机名称 快照序号virsh snapshot-delete Centos_6.7 1520271801 //将Centos_6.7虚拟机"Name"为1520271801的快照删除]]></content>
      <categories>
        <category>KVM</category>
      </categories>
      <tags>
        <tag>kvm</tag>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MFS分布式文件系统]]></title>
    <url>%2FLinuxService%2FMFS%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[MooseFS是一个具有容错性的网络分布式文件系统。它把数据分散存放在多个物理服务器上，而呈现给用户的则是一个统一的资源。 一、MooseFS MooseFS是一个具有容错性的网络分布式文件系统。它把数据分散存放在多个物理服务器上，而呈现给用户的则是一个统一的资源。 Moose文件系统（MooseFS）是由Core Technology开发的开源，POSIX兼容的分布式文件系统。MooseFS旨在为数据中心提供容错，高可用，高性能，可扩展的通用网络分布式文件系统。最初是专有软件，它于2008年5月5日作为开源向公众发布。 目前有两个版本的MooseFS：MooseFS - 根据GPLv2许可发布，MooseFS专业版（MooseFS Pro） - 以二进制包形式的专有许可证发布。 官网地址：http://www.moosefs.com/ 二、组成 MooseFS遵循与Fossil（文件系统），Google File System，Lustre或Ceph类似的设计原则。文件系统包括三个组件： 元数据服务器（Master） - 维护和管理文件的位置（布局），文件访问和命名空间层次结构。当前版本的MooseFS支持多个元数据服务器和自动故障转移。客户端只与MDS通信以检索/更新文件的布局和属性; 数据本身直接在客户端和块服务器之间传输。元数据服务器是用户空间守护程序 ; 元数据保存在内存中，并且懒惰地存储在本地磁盘上。 元数据日志服务器（Metalogger）- 纪录数据的改动情况，定期从MDS中提取元数据以存储它以进行备份。从版本1.6.5开始，这是一个可选功能。 块服务器（Chunk Server） - 存储数据并可选地在它们之间进行复制。虽然可扩展性限制尚未发布，但可能有很多。迄今为止报告的最大集群包括160台服务器。[7] Chunk服务器也是一个用户空间守护程序，它依赖于底层本地文件系统来管理实际存储。 客户端 - 与Master和ChunkServer交谈。MooseFS客户端通过FUSE将文件系统挂载到用户空间。 三、原理 MFS读过程 客户端向Master发送读请求 Master去缓存的数据库（非MySQL）中搜索客户端所需数据的位置，并告知客户端（Chunk Server IP、Chunk编号） 客户端去指定Chunk Server的对应Chunk编号读取数据 客户端通知Master读取完毕 MFS写过程 客户端向Master发送写请求 Master通知Chunk Server（谁空闲，如空闲新建Chunk编号），找到后将知道的Chunk Server IP和编号告知客户端 客户端向指定IP和编号存储数据 客户端告知Master写入完毕 Master通知Metalogger有新数据写入（Matelogger纪录新增加文件位置和对应Chunk Server），日志记录完毕后，连接关闭 四、功能 为实现高可靠性和高性能，MooseFS提供以下功能： 容错 - MooseFS使用复制，可以跨块服务器复制数据，每个文件/目录设置复制比率（N）。如果（N-1）个副本失败，则数据仍然可用。目前，MooseFS没有提供任何其他容错技术。因此，对于非常大的文件的容错需要大量的空间–N *文件大小而不是文件大小+（N * stripeize），如RAID 4，RAID 5或RAID 6的情况。MooseFS版本4.x PRO将具有RAID6。 条带化 - 大文件分为块（最多64 兆字节），可以存储在不同的块服务器上，以实现更高的聚合带宽。 负载平衡 - MooseFS尝试平等地使用存储资源，当前算法似乎只考虑消耗的空间。 安全性 - 除了经典的POSIX文件权限之外，自1.6版本发布以来，MooseFS提供了一个简单的，类似NFS的身份验证 / 授权。 相干快照 - 快速，低开销的快照。 透明的“垃圾桶” - 删除的文件将保留一段可配置的时间。 数据分层/存储类 - 可以“标记”服务器，创建称为“存储类”的标签定义，并决定数据存储在哪些类型的服务器上[8] “项目”配额支持 POSIX锁，flock锁支持 四、数据存储方式 文件以chunk大小存储，每chunk最大为64M。小于64M的，该chunk的大小即为该文件大小，超过64M的文件将被均分，每一份（chunk）的大小以不超过64M为原则；文件可以有多份copy，即除原始文件以外，该文件还存储的份数。当goal为1时，表示只有一份copy，这份copy会被随机存到一台chunkserver上。当goal的数大于1时，每一份copy会被分别保存到其它chunkserver上。goal的大小不要超过chunkserver的数量，否则多出的copy，不会有chunkserver去存，goal设置再多实际上也就没有意义的。copy的份数，一般设为大于1份，这样如果有一台chunkserver坏掉后，至少还有一份copy，当这台又被加进来后，会将失去的那份copy补回来，始终保持原有的copy数。而如果goal设为1，那么当存储该copy的chunkserver坏掉，之后又重新加入回来，copy数将始终是0，不会恢复到之前的1个copy chunkserver上的剩余存储空间要大于1GB，新的数据才会被允许写入，否则，你会看到No space left的提示 多个chunker并不影响写的速度，但是能加快读的速度，在原来的基础上增加一个chunker时，数据会自动同步到新增的chunker上以达到数据的平衡和均衡 五、常见问题 详情见：https://moosefs.com/faq/ 六、部署MFS 环境准备 Role IP OS RPM Master 192.168.0.21 CentOS6.7_64bit mfs-1.6.27-5.tar.gz MetaLogger 192.168.0.22 CentOS6.7_64bit mfs-1.6.27-5.tar.gz Chunk Server 1 192.168.0.23 CentOS6.7_64bit mfs-1.6.27-5.tar.gz Chunk Server 2 192.168.0.24 CentOS6.7_64bit mfs-1.6.27-5.tar.gz Client 192.168.0.25 CentOS6.7_64bit mfs-1.6.27-5.tar.gz fuse-2.9.2.tar.gz 搭建Master Servera.安装环境包并创建用户 12345678vim /etc/sysconfig/network-scripts/ifcfg-eth0DEVICE=eth0TYPE=EthernetONBOOT=yesNM_CONTROLLED=noBOOTPROTO=staticIPADDR=192.168.0.21NETMASK=255.255.255.0 1yum -y install zlib-devel //安装依赖环境 1useradd -s /sbin/nologin mfs //创建mfs运行用户 1tar -zxvf mfs-1.6.27-5.tar.gz -C /usr/src/ &amp;&amp; cd /usr/src/mfs-1.6.27 //解包 1./configure --prefix=/usr/local/mfs --with-default-user=mfs --with-default-group=mfs --disable-mfschunkserver --disable-mfsmount //配置选项 1make &amp;&amp; make install //编译并安装 1cd /usr/local/mfs/ 123456ll //看下安装完成生成的目录drwxr-xr-x 2 root root 4096 Dec 3 11:24 bin //客户端工具drwxr-xr-x 3 root root 4096 Dec 3 11:24 etc //服务器的配置文件都放在该目录中 drwxr-xr-x 2 root root 4096 Dec 3 11:24 sbin //服务端启动程序。如：元数据服务器端程序 mfsmaster、数据存储服务器端服务程序mfschunkserver drwxr-xr-x 4 root root 4096 Dec 3 11:24 share //文档 drwxr-xr-x 3 root root 4096 Dec 3 11:24 var //元数据目录（可在配置文件中自定义到其他目录） b.复制文件 1cd /usr/local/mfs/etc/mfs/ 1cp mfsmaster.cfg.dist mfsmaster.cfg //Master配置文件 1cp mfstopology.cfg.dist mfstopology.cfg //输出目录配置文件 1cp mfsexports.cfg.dist mfsexports.cfg //元数据日志 12cp /usr/local/mfs/var/mfs/metadata.mfs.empty /usr/local/mfs/var/mfs/metadata.mfs//首次安装 master 时，会自动生成一个名为 metadata.mfs.empty 的元数据文件 metadata,该文件是空的。MooseFS master 运必须有文件 metadata.mfs c.启动Master Servermaster 会打开 9420 端口等待 chunkserver 数据存储服务器连接1/usr/local/mfs/sbin/mfsmaster start //启动master服务 1ps -ef | grep mfs 123456ll /usr/local/mfs/var/mfs/ //查看生成的日志文件-rw-r----- 1 mfs mfs 95 Dec 24 14:30 metadata.mfs-rw-r----- 1 mfs mfs 95 Dec 24 14:28 metadata.mfs.back.1-rw-r--r-- 1 mfs mfs 8 Dec 24 14:13 metadata.mfs.empty-rw-r----- 1 mfs mfs 10 Dec 24 14:28 sessions.mfs-rw-r----- 1 mfs mfs 762516 Dec 24 14:30 stats.mfs 1/usr/local/mfs/sbin/mfsmaster stop //服务的关闭方法 1/usr/local/mfs/sbin/mfscgiserv start //启动web统计 1IE --&gt; 192.168.0.21:9425 //访问web统计界面 搭建MetaLogger Servera.安装环境包并创建用户12345678vim /etc/sysconfig/network-scripts/ifcfg-eth0DEVICE=eth0TYPE=EthernetONBOOT=yesNM_CONTROLLED=noBOOTPROTO=staticIPADDR=192.168.0.22NETMASK=255.255.255.0 1yum -y install zlib-devel 1useradd -s /sbin/nologin mfs 1tar -zxvf mfs-1.6.27-5.tar.gz -C /usr/src/ &amp;&amp; cd /usr/src/mfs-1.6.27 1./configure --prefix=/usr/local/mfs --with-default-user=mfs --with-default-group=mfs --disable-mfschunkserver --disable-mfsmount 1make &amp;&amp; make install b.复制文件1cd /usr/local/mfs/etc/mfs/ 1cp mfsmetalogger.cfg.dist mfsmetalogger.cfg 123vim mfsmetalogger.cfgMASTER_HOST = 192.168.0.21//MASTER_HOST，这个文件中需要修改的是 MASTER_HOST 变量，这个变量的值是 MASTER SERVER 的 IP 地址 c.启动Metalogger Server1/usr/local/mfs/sbin/mfsmetalogger start 1ps -ef | grep mfs 搭建Chunk Server 1a.安装环境包并创建用户12345678vim /etc/sysconfig/network-scripts/ifcfg-eth0DEVICE=eth0TYPE=EthernetONBOOT=yesNM_CONTROLLED=noBOOTPROTO=staticIPADDR=192.168.0.23NETMASK=255.255.255.0 1yum -y install zlib-devel 1useradd -s /sbin/nologin mfs 1tar -zxvf mfs-1.6.27-5.tar.gz -C /usr/src/ &amp;&amp; cd /usr/src/mfs-1.6.27 1./configure --prefix=/usr/local/mfs --with-default-user=mfs --with-default-group=mfs --disable-mfsmaster --disable-mfsmount 1make &amp;&amp; make install b.复制文件1cd /usr/local/mfs/etc/mfs/ 1cp mfschunkserver.cfg.dist mfschunkserver.cfg 1cp mfshdd.cfg.dist mfshdd.cfg 12vim mfschunkserver.cfgMASTER_HOST = 192.168.0.21 123vim mfshdd.cfg/data//数据存放的目录，一般为一块磁盘的挂载目录 1mkdir /data 1chown -R mfs:mfs /data c.启动Chunk服务1/usr/local/mfs/sbin/mfschunkserver start 1ps -ef | grep mfs 搭建Chunk Server2a.安装环境包并创建用户12345678vim /etc/sysconfig/network-scripts/ifcfg-eth0DEVICE=eth0TYPE=EthernetONBOOT=yesNM_CONTROLLED=noBOOTPROTO=staticIPADDR=192.168.0.24NETMASK=255.255.255.0 1yum -y install zlib-devel 1useradd -s /sbin/nologin mfs 1tar -zxvf mfs-1.6.27-5.tar.gz -C /usr/src/ &amp;&amp; cd /usr/src/mfs-1.6.27 1./configure --prefix=/usr/local/mfs --with-default-user=mfs --with-default-group=mfs --disable-mfsmaster --disable-mfsmount 1make &amp;&amp; make install b.复制文件 1cd /usr/local/mfs/etc/mfs/ 1cp mfschunkserver.cfg.dist mfschunkserver.cfg 1cp mfshdd.cfg.dist mfshdd.cfg 12vim mfschunkserver.cfgMASTER_HOST = 192.168.0.21 12vim mfshdd.cfg/data 1mkdir /data &amp;&amp; chown mfs:mfs /data c.启动Chunk服务 1/usr/local/mfs/sbin/mfschunkserver start 1ps -ef | grep mfs client挂载MFS文件系统a.安装fuse12345678vim /etc/sysconfig/network-scripts/ifcfg-eth0DEVICE=eth0TYPE=EthernetONBOOT=yesNM_CONTROLLED=noBOOTPROTO=staticIPADDR=192.168.0.25NETMASK=255.255.255.0 1tar -zxvf fuse-2.9.2.tar.gz -C /usr/src/ &amp;&amp; cd /usr/src/fuse-2.9.2 1./configure &amp;&amp; make &amp;&amp; make install 12vim /etc/profileexport PKG_CONFIG_PATH=/usr/local/lib/pkgconfig:$PKG_CONFIG_PATH 1source /etc/profile b.安装MFS客户端1useradd -s /sbin/nologin mfs 1tar -zxvf ~/mfs-1.6.27-5.tar.gz -C /usr/src/ &amp;&amp; cd /usr/src/mfs-1.6.27 1./configure --prefix=/usr/local/mfs --with-default-user=mfs --with-default-group=mfs --disable-mfsmaster --disable-mfschunkserver --enable-mfsmount 1make &amp;&amp; make install c.挂载MFS文件系统1modprobe fuse //加载fuse模块到内核 12vim /etc/rc.local //开机自动加载modprobe fuse 1/usr/local/mfs/bin/mfsmount /media -H 192.168.0.21 //挂载 12[root@mfs_client ~]# /usr/local/mfs/bin/mfssetgoal -r 1 -H /media///更改随机copy的次数 12[root@mfs_client ~]# /usr/local/mfs/bin/mfsgetgoal -H /media///查看当前copy的次数]]></content>
      <categories>
        <category>LinuxService</category>
      </categories>
      <tags>
        <tag>MFS分布式文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git分布式版本控制系统]]></title>
    <url>%2FVCS%2FGit%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[Git是一个版本控制系统用于跟踪变化的计算机文件和协调多人之间的那些文件的工作。它主要用于源代码管理在软件开发，但它可以被用来跟踪变化的任何文件集。作为分布式版本控制系统，它旨在提高速度，数据完整性，并支持分布式非线性工作流程。 Git简介 Git是一个版本控制系统用于跟踪变化的计算机文件和协调多人之间的那些文件的工作。 它主要用于源代码管理在软件开发，但它可以被用来跟踪变化的任何文件集。作为分布式版本控制系统，它旨在提高速度，数据完整性，并支持分布式非线性工作流程。 与大多数其他分布式版本控制系统一样，与大多数客户端 - 服务器系统不同，每台[计算机上的每个Git 目录都是一个完整的存储库，具有完整的历史记录和完整的版本跟踪能力，独立于网络访问或中央服务器。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。其他内核开发人员为其初始开发做出了贡献。 自2005年以来，它目前的维护者是Junio Hamano。 Torvalds 开始着手开发 Git 是为了作为一种过渡方案来替代 BitKeeper，后者之前一直是 Linux 内核开发人员在全球使用的主要源代码工具。开放源码社区中的有些人觉得BitKeeper 的许可证并不适合开放源码社区的工作，因此 Torvalds 决定着手研究许可证更为灵活的版本控制系统。尽管最初 Git 的开发是为了辅助 Linux 内核开发的过程，但是我们已经发现在很多其他自由软件项目中也使用了 Git。例如 很多 Freedesktop 的项目迁移到了 Git 上。 Git是根据GNU通用公共许可证版本2 的条款分发的免费开源软件。 Git的历史 起初参与Linux开源项目的代码是由Linus Torvalds本人通过”diff”和”patch”（用于比较两个文件的区别）命令来手动为别人整合代码的，随着项目越做越大，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满。 你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。 diff简介作用：比较文件中的不同点格式：diff 文件A 文件B &gt;文件Cdiff命令用于比较文本文件，能比较单个文件或者目录内容，但只有当输入为文本文件时才有效如果指定了Directory1和Directory2参数，diff命令比较两个目录下名字相同的文本文件，并列出不同的二进制文件、公共子目录和只在一个目录出现的文件diff命令主要用于比较两个文件的差异，并制作成补丁文件，然后使用patch命令对相应的文件打补丁 于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统 直到2005年，Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气，开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错），于是BitMover公司怒了，要收回Linux社区的免费使用权 于是Linus向BitMover公司道个歉，保证以后严格管教弟兄们（嗯，这是不可能的）随后，Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git，一个月之内，Linux系统的源码已经由Git管理了，Git也由此诞生了 Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。 集中式和分布式 Linus一直痛恨的CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统，集中式和分布式版本控制系统有什么区别呢？ 先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。 集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。 那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。 在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。 当然，Git的优势不单是不必联网这么简单，后面我们还会看到Git极其强大的分支管理，把SVN等远远抛在了后面。 CVS作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的SVN修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。 除了免费的外，还有收费的集中式版本控制系统，比如IBM的ClearCase（以前是Rational公司的，被IBM收购了），特点是安装比Windows还大，运行比蜗牛还慢，能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗，或者人傻钱多。 微软自己也有一个集中式版本控制系统叫VSS，集成在Visual Studio中。由于其反人类的设计，连微软自己都不好意思用了。 分布式版本控制系统除了Git以及促使Git诞生的BitKeeper外，还有类似Git的Mercurial和Bazaar等。这些分布式版本控制系统各有特点，但最快、最简单也最流行的依然是Git！ Git和SVN的区别 Git是分布式，SVN是集中式 Git的每个历史版本存储的是完整的文件，而SVN只是存储文件的差异 Git可以离线完成大部分操作，SVN不可以 Git有着更优雅的分支和合并实现 Git有更强的撤销修改和修改版本历史的能力 Git速度更快，效率更高 Git和Github的关系 Git是一个分布式的版本控制系统 GitHub是一个基于Git的项目托管平台，它提供了web界面，我们可以在上面创建资源仓库来存放你的项目 在本地或服务器创建一个资源仓库通过shell命令或图形用户界面可以和远端的GitHub进行项目同步更新，实现对项目的管理 Git的安装 yum安装Git12yum -y install git//安装git软件包（一般自带），或者源码编译新版本（源码编译时，注意安装curl-devel软件包） 源码安装Git点击下载git-2.19.0.tar.xz的源码包 123456789yum -y install perl-ExtUtils-MakeMaker gettext-devel expat-devel curl-devel zlib-devel openssl-devel openssl-devel gcc-c++ make //安装依赖包tar -Jxvf git-2.19.0.tar.xz -C /usr/src/cd /usr/src/git-2.19.0/make prefix=/usr/local/git all //编译所有模块make prefix=/usr/local/git install //安装echo "export PATH=$PATH:/usr/local/git/bin"&gt;&gt; /etc/profile //将命令添加到环境变量yum -y erase git //卸载yum安装的gitsource /etc/profile //重新读取环境变量文件使之生效git --version //验证git是否为源码编译版本 Git入门 基本配置 本地仓库中的代码最终是要上传到GitHub中，而在上传的时候，必须要指定个人信息，包括用户名和邮箱地址，方便团队或者项目组中其他人员知道是谁修改或者上传了代码，所以首先要设置用户名和邮箱地址 设置用户名和邮箱 该用户名、邮箱应为Github网站注册填写的用户名及邮箱 123git config --global user.name用户名 //设置用户名git config --global user.email 邮箱地址 //设置邮箱git config –list //查看git配置 注：也可通过”vim ~/.gitconfig”指定用户名及邮箱 删除用户信息1git config --global --unset user.name 用户名 //如果有多个用户，想删除指定的用户可以使用 基本操作创建本地仓库1git init //在当前目录，初始化本地仓库,也可在`git init`后面添加指定的目录 创建并编辑文件 直接在本地仓库下新建文件即可 例： vim /opt/git/Demo.txt //在本地工作目录下新建文件 ​ 第一次 将文件新增到暂存区 刚才创建的Demo.txt文件虽然在本地仓库目录下，但是并没有被仓库所管理，这时需要使用git add让文件被仓库管理（进入暂存区） 1git add 文件路径 例： git status //查看当前仓库文件状态（可以看出，没有提交和新增文件，但有跟踪到新文件） git add Demo.txt //将文件提交到暂存区 git status //再次验证后，文件状态发生改变 将文件提交到历史仓库1git commit -m "文字说明" 例： git commit -m “第一次提交” //将所有暂存区内容提交到仓库 git status //再次查看仓库状态后，可以看见无任何内容 注：所有新增或更改的文件都会先放在暂存区，但确认无误时，在使用commit提交（这样的好处在于，如果更改错误随时可以回退） 对文件进行修改 例： vim /opt/git/Demo.txt //测试，修改下文件内容 ​ 第一次 ​ 第二次 git status //查看仓库状态后，可以看见检测到文件发生更改，但没有新增和提交 此时，我们对修改的文件有两种处理方式 ①确实需要修改，那么我们使用git add将文件放进暂存区 ②如果是误修改，我们可以将文件回滚到之前的版本 对比文件差异1git diff 文件 //查看文件变动情况 例： git diff Demo.txt //查看文件更改情况，显示新增第二行内容 撤销修改 这里的撤销指的是，修改的文件还没有被提交（git add命令）到暂存区 1git checkout 文件 //撤销指定文件修改（未提交到暂存区前） 例： cat Demo.txt //查看当前文件内容 git checkout Demo.txt //撤销文件修改 git status //仓库状态查看后，无内容 cat Demo.txt //再次验证文件内容，证明文件撤销成功 如果修改的文件已提交到缓存区 1git reset HEAD 文件 //取消指定文件的暂存区修改（再使用checkout即可） 例： cat Demo.txt //查看当前文件内容 vim /opt/git/Demo.txt //测试，修改下文件内容 ​ 第一次 ​ 第二次 git status //查看仓库状态后，可以看见检测到文件发生更改，但没有新增和提交 git add Demo.txt //将文件修改提交到暂存区 git status //再次验证后，文件状态发生改变 git checkout Demo.txt //撤销文件修改 cat Demo.txt //验证结果，撤销失败 git reset HEAD Demo.txt //取消Demo.txt文件暂存区的更改 git status //查看仓库状态后，可以看见检测到文件发生更改，但没有新增和提交（代表新增操作还原） git checkout Demo.txt //再次执行撤销文件操作 cat Demo.txt //验证结果，撤销成功 工作区，暂存区，历史仓库基本描述 当git init初始化git仓库之后，在文件夹中会多出一个.git隐藏文件夹，这个.git隐藏文件夹就是git的版本库repository 创建Git仓库的文件夹就是工作区working directory 暂存区：暂存区可以理解为一个虚拟工作区，这个虚拟工作区会跟踪工作区的文件变化（增删改等操作），工作区的位于.git文件夹下的index目录下 注意点 当需要对工作区的修改提交到版本库前，暂存区会与工作区进行差异比较，如果工作区与暂存区的文件不一致，那么需要同步工作区的修改到暂存区，然后才可以提交到版本库 暂存区可以说是工作区和版本库的桥梁，我们对文件的修改可以先放在暂存区中，如果后悔了不仅可以非常方便撤销，而且不会影响到现有的版本库 只要我们使用过git add，那么文件就会被跟踪，暂存区跟踪记录了工作区的文件名和文件状态（在index文件中会记录修改时间，文件大小等信息），当下次对文件进行修改的时候，会比较时间戳来判断文件是否被修改 并且在执行git status时，首先会到.git/index下查看被跟踪的工作区文件的时间戳，如果发现自上次执行git add（执行git add可以让工作区的文件被跟踪）以来，文件的时间戳发生了变化，那么判断文件发生了改动，于是会与暂存区的原始文件与工作区中的该文件进行差异比较，如果发现两个文件内容不一致，那么就给出差异信息 实例演示 cd /opt/git //进入工作目录 touch newfile.txt //创建空文件 vim Demo.txt //修改已提交暂存区的文件内容 ​ 第一次 ​ 第二次 git status //查看当前仓库状态 git diff //查看暂存区和工作区文件差异 git add newfile.txt Demo.txt //将指定两个文件添加到暂存区 git status //再次查看当前仓库状态 git diff //这时再次比对暂存区和工作区差异，无区别 git commit -m “第二次更改” //将暂存区所有文件提交 git status //再次查看仓库暂存区状态，无内容 查询历史提交记录1git log //查询所有提交的历史文件commit id、作者以及提交时间、提交信息但是不包括之前删除的历史记录 1git log --pretty=oneline //只查询所有提交文件的commit id 1git log --pretty=oneline 文件名 //查询指定某个文件的commit id 1git reflog git log和git reflog的区别 git log查询的是commit id，作者以及提交时间和提交信息，但是不包括之前删除的历史记录 git reflog查询的是简洁的commit id和提交信息，也会包含之前删除的历史记录 回退历史版本1git reset 版本ID //回退到指定版本（版本id可通过git relog查看） 例： git reflog //查看所有提交文件版本id git reset fc3523e //回退到指定版本id时的状态 git status //查看仓库状态 git checkout Demo.txt //撤销Demo.txt文件修改 cat Demo.txt //验证结果，回滚成功 误删除工作区的文件 例： rm -rf Demo.txt //模拟文件删除 ls //验证文件是否删除 git status //仓库状态更改 git checkout Demo.txt //撤销Demo.txt文件修改操作 git status //再次查看仓库状态 ls //验证文件是否还原 cat Demo.txt //验证结果，还原成功 真正删除文件1git rm 文件 //从仓库中删除指定文件 例： ls //查看文件 git rm Demo.txt //从仓库中删除Demo.txt git commit -m “删除Demo.txt文件” //提交删除操作到仓库 ls //验证文件是否删除 git status //再次查看仓库状态 GitHub账号注册：https://github.com/ 与远程仓库关联 在本地生成ssh key1ssh-keygen -t rsa -C "邮箱地址" 例： ssh-keygen -t rsa -C “GitHub注册邮箱” //本地生成rsa算法的私钥及公钥文件，-C指定标识名称 Github中添加公钥 在GitHub中创建一个远程仓库 复制远程仓库的地址 本地clone远程仓库1git clone https://github.com/CallousMaster/callousmaster.github.io.git 如出现：”fatal: HTTP request failed”，则有可能是git版本太低，需源码安装高版本。详情见开头的源码安装Git 如出现：”fatal: unable to access ‘https://github.com/CallousMaster/callousmaster.github.io.git/&#39;: SSL connect error “，需更新系统软件包 123wget -O /etc/yum.repos.d/CentOS-Base.repohttp://mirrors.aliyun.com/repo/Centos-6.repo //下载在线源yum -y update //更新系统系统所有包reboot //重启后，即可正常使用 本地修改代码之后提交到远程仓库vim demo.txt //在仓库下新增文件 ​ 第一次提交GitHub git add demo.txt //将文件添加到暂存区 git commit -m “第一次更改” //将暂存区内容提交到本地仓库 git status //仓库状态查看后，提示需提交到远程仓库 git remote add first https://github.com/CallousMaster/callousmaster.github.io.git //在本地仓库添加一个远程仓库，后面的地址是远程仓库的地址，first为远程仓库标识名称可自定义 git push -u first master //将本地仓库内容提交到远程仓库master分支（第一次-u必须使用，之后提交操作可以忽略），注意输入用户名、密码 可以使用命令**git remote rm first删除关联的远程仓库** 使用**git remote show first来查看first远程仓库的具体分支** 使用**git remote –v来查看与当前本地仓库相关联的远程仓库** 例： git remote -v git remote rm origin //删除名称为origin的远程仓库链接 git remote -v git remote show first //查看指定远程仓库信息 在GitHub上查看差异文件修改本地仓库的文件并上传vim demo.txt //在仓库下新增文件 ​ 第一次提交GitHub ​ 第二次提交GitHub git add demo.txt //将文件添加到暂存区 git commit -m “第二次修改” git push first master //将本地仓库内容提交到远程仓库master分支 上传成功后，在GitHub上查询差异 分支管理 分支的引入 Master 是主分支，主要作为程序的发布，可以理解为是项目的最终版本，所以不能在master上进行开发，所以应该建立子分支进行开发 团队中多个人开发一下项目，一同事在开发一个新的功能，需要一周时间完成，他写了其中的50%还没有写完，如果他提交了这个版本，那么团队中的其它人就不能继续开发了，但是等到他全部写完再全部提交，又存在每天进度丢失的风险，这如何是好呢？ 对于上面的这个问题，我们就可以用分支管理的办法来解决，一同事开发新功能他可以创建一个属于他自己的分支，其它同事暂时看不到，继续在开发分支（一般都有多个分支）上干活，他在自己的分支上干活，等他全部开发完成，再一次性的合并到主分支上，这样我们既可知道他的开发进度，又不影响大家干活 其他的版本控制器也有分支的概念，只不过切换，删除分支的时候非常慢、效率低下，而git切换或者删除分支几乎就是一瞬间的事 查看分支1git branch //查看分支，默认只有一个master 创建分支1git branch 分支名称 例： git branch test //创建名称为test的新分支 git branch 切换分支1git checkout 分支名称 例： git checkout test //切换到test分支工作 git branch 创建并切换分支1git checkout -b 分支名称 例： git checkout -b test2 //创建test2新分支并切换到该分支 git branch 删除分支1git branch -d 分支名称 注：如果要删除的分支，正处于当前工作分支，必须切换到其余分支中才能删除 例： git branch -d test //删除名为test分支 git branch 合并分支 例： git branch //查看当前所处分支 vim test2.txt //在test2分支下新建test2.txt文件 test2 git add test2.txt //将文件提交到暂存区 git commit -m “test2分支下新建文件” //将暂存区内容提交到本地仓库 git checkout master //切换到master分支 ls //验证后，发现test2分支文件不能查看 git merge test2 //将test2分支合并到当前分支 ls //合并分支后，文件新增 解决冲突 代码冲突如何产生的：当在分支上进行开发的时候，难免遇到别的开发人员和我们自己向仓库中提交相同的代码 比如有一个商城的项目，开发人员A和开发人员B都对同一段代码做了修改，当A进行提交后并push到远程仓库中master合并，B再进行提交并与远程仓库中的master进行合并这时候就会出现代码冲突 例： git checkout test2 //切换到test2分支 vim test2.txt //编辑文件 ​ test2 test2分支修改 git add test2.txt //添加文件到暂存区 git commit -m “test2分支修改” //将暂存区内容提交到test2分支 git checkout master //切换到master分支 vim test2.txt //master分支下，再次修改该文件 ​ test2 主分支更改 git add test2.txt //添加更改到暂存区 git commit -m “master分支修改” //将暂存区内容提交到master分支 git merge test2 //将test2分支合并到当前分支 git status //仓库状态查看 cat test2.txt //查看合并后文件内容（这时能看见两个分支更改内容，将冲突删除或修改） vim test2.txt //合并文件 ​ test2 合并完毕 git add test2.txt //添加更改到暂存区 git commit -m “master解决冲突” //将暂存区内容提交到master分支 git merge test2 //将test2分支合并到当前分支 cat test2.txt //验证合并情况 标签管理 基本介绍标签就是版本库的一个快照，在发布新版本的时候，一般都会给老的版本打个标签，方便后续直接使用指定的版本 查询和创建标签1git tag //查询标签 1git tag 标签名称 //创建标签 例： git tag version1 //创建version标签（默认无标签） git tag 1git tag -a 标签名称 -m "描述信息" //新建标签，并添加描述信息 例： git tag -a version2 -m “版本2” //新建version2标签，并添加描述信息 git tag 1git tag 标签名称 commitID //给之前忘记打标签的文件，设置标签 例： git log –pretty=oneline //查看当前分支所有已提交文件id git tag version3 89c87e8f33aac869861a20928ec133862281a980 //给指定commit id创建标签 查询标签说明1git show 标签名称 //查看标签信息 例： git show version //查看version3标签信息 删除本地标签1git tag -d 标签名称 //删除标签 例： git tag//查看当前所有标签 git tag -d version2 //删除version2标签 git tag //验证标签是否删除 提交标签到远程仓库提交指定的版本号到远程仓库1git push 远程仓库名 标签名称 //提交标签到远程仓库 例： git push first version1 //将version1标签提交到远程仓库 提交所有版本号到远程仓库1git push 远程仓库名 --tags //提交所有版本号到远程仓库 例： git push first –tags //提交本地仓库所有标签 删除远程仓库标签首先删除本地标签 例： git tag -d version1 //删除本地version1标签 再删除远程标签 git push first :refs/tags/version1 //远程远程version1标签]]></content>
      <categories>
        <category>VCS</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>VCS</tag>
      </tags>
  </entry>
</search>
